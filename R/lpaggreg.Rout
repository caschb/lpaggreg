
R version 3.2.3 (2015-12-10) -- "Wooden Christmas-Tree"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R est un logiciel libre livré sans AUCUNE GARANTIE.
Vous pouvez le redistribuer sous certaines conditions.
Tapez 'license()' ou 'licence()' pour plus de détails.

R est un projet collaboratif avec de nombreux contributeurs.
Tapez 'contributors()' pour plus d'information et
'citation()' pour la façon de le citer dans les publications.

Tapez 'demo()' pour des démonstrations, 'help()' pour l'aide
en ligne ou 'help.start()' pour obtenir l'aide au format HTML.
Tapez 'q()' pour quitter R.

> require(inline)
Le chargement a nécessité le package : inline
> require(Rcpp)
Le chargement a nécessité le package : Rcpp

Attachement du package : ‘Rcpp’

The following object is masked from ‘package:inline’:

    registerPlugin

> require(RcppArmadillo)
Le chargement a nécessité le package : RcppArmadillo
> 
> #Modify
> lpaggreg_location="/opt/ptools/lpaggreg";
> #Don't touch
> cxxflags=paste("-I",lpaggreg_location,"/include/", sep="");
> libs=paste("-L",lpaggreg_location,"/lib/ -llpaggreg -Wl,-rpath=",lpaggreg_location,"/lib/", sep="");
> Sys.setenv("PKG_CXXFLAGS"=cxxflags);
> Sys.setenv("PKG_LIBS"=libs);
> 
> src <- '
+   // Enable C++11
+   // [[Rcpp::plugins(cpp11)]]
+ 
+   #include <RcppArmadillo.h>
+   // [[Rcpp::depends(RcppArmadillo)]]
+ 
+   #include <iostream>
+   #include <vector>
+   #include <map>
+   #include <memory>
+   #include <lpaggreg/oqualities.h>
+   #include <lpaggreg/opartitioner.h>
+   #include <lpaggreg/ovaluesn.h>
+   #include <lpaggreg/hqualities.h>
+   #include <lpaggreg/hpartitioner.h>
+   #include <lpaggreg/hvaluesn.h>  
+ 
+   using namespace Rcpp;
+   using namespace arma;
+   using namespace std;
+   using namespace lpaggreg;
+ 
+   vector<vector<vector<double> > > getMicroModel(NumericVector data){
+     NumericVector vecArray(data);
+     IntegerVector arrayDims = vecArray.attr("dim");
+     arma::cube cubeArray(vecArray.begin(), arrayDims[0], arrayDims[1], arrayDims[2], false);
+     vector<vector<vector<double> > > micromodel;
+     for (int i=0; i<arrayDims[0]; i++){
+       micromodel.push_back(vector<vector<double> >());
+       for (int j=0; j<arrayDims[1]; j++){
+         (micromodel[i]).push_back(vector<double>());
+         for (int k=0; k<arrayDims[2]; k++){
+           (micromodel[i][j]).push_back(cubeArray(i, j, k));
+         }
+       }
+     }
+     return micromodel;
+   }
+ 
+   vector<int> getHierarchy(NumericVector h){
+     vector<int> hierarchy;
+     for (int i=0; i<h.size(); i++){
+       hierarchy.push_back(h(i));
+     }
+     return hierarchy;
+   }
+  
+   // [[Rcpp::export]]
+   NumericMatrix oaggregate(NumericVector data) {
+     vector<vector<vector<double> > > micromodel=getMicroModel(data);
+     //float th=Rcpp::as<float>(threshold);
+     shared_ptr<OValuesN3> values = shared_ptr<OValuesN3>(new OValuesN3(micromodel));
+     OQualities oqualities = OQualities(values);
+     oqualities.computeQualities();
+     oqualities.normalize();
+     OPartitioner opartitioner = OPartitioner(oqualities);
+     opartitioner.computeBestPartitions(0.001);
+     list< tuple<float, int, int> > partitionsTuples=opartitioner.getPartitionsTuples();
+     NumericMatrix matrixResults(partitionsTuples.size(),3);
+     int i=0;
+     for (tuple<float, int, int> line: partitionsTuples){
+       matrixResults(i, 0)=get<0>(line);
+       matrixResults(i, 1)=get<1>(line);
+       matrixResults(i, 2)=get<2>(line);
+       i++;
+     }
+     return matrixResults;
+   }
+ /*
+   // [[Rcpp::export]]
+   NumericMatrix haggregate(NumericVector data, NumericVector hierarchy) {
+     vector<vector<vector<double> > > micromodel=getMicroModel(data);
+     vector<int> h=getHierarchy(hierarchy);
+     //float th=Rcpp::as<float>(threshold);
+     shared_ptr<HValuesN3> values = shared_ptr<HValuesN3>(new HValuesN3(micromodel, h));
+     HQualities hqualities = HQualities(values);
+     hqualities.computeQualities();
+     hqualities.normalize();
+     HPartitioner hpartitioner = HPartitioner(hqualities);
+     hpartitioner.computeBestPartitions(0.001);
+     list< tuple<float, int, int> > partitionsTuples=hpartitioner.getPartitionsTuples();
+     NumericMatrix matrixResults(partitionsTuples.size(),3);
+     int i=0;
+     for (tuple<float, int, int> line: partitionsTuples){
+       matrixResults(i, 0)=get<0>(line);
+       matrixResults(i, 1)=get<1>(line);
+       matrixResults(i, 2)=get<2>(line);
+       i++;
+     }
+     return matrixResults;
+   }*/
+ '
> 
> sourceCpp(code=src, verbose=TRUE, rebuild=TRUE)

Generated extern "C" functions 
--------------------------------------------------------


#include <Rcpp.h>
// oaggregate
NumericMatrix oaggregate(NumericVector data);
RcppExport SEXP sourceCpp_1_oaggregate(SEXP dataSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericVector >::type data(dataSEXP);
    rcpp_result_gen = Rcpp::wrap(oaggregate(data));
    return rcpp_result_gen;
END_RCPP
}

Generated R functions 
-------------------------------------------------------

`.sourceCpp_1_DLLInfo` <- dyn.load('/tmp/RtmpXROjK2/sourceCpp-x86_64-redhat-linux-gnu-0.12.7/sourcecpp_419b29d50579/sourceCpp_2.so')

oaggregate <- Rcpp:::sourceCppFunction(function(data) {}, FALSE, `.sourceCpp_1_DLLInfo`, 'sourceCpp_1_oaggregate')

rm(`.sourceCpp_1_DLLInfo`)

Building shared library
--------------------------------------------------------

DIR: /tmp/RtmpXROjK2/sourceCpp-x86_64-redhat-linux-gnu-0.12.7/sourcecpp_419b29d50579

/usr/lib64/R/bin/R CMD SHLIB -o 'sourceCpp_2.so' --preclean  'file419b7d5bd2e4.cpp'  
g++ -m64 -std=c++11 -I/usr/include/R -DNDEBUG  -I/usr/local/include  -I"/usr/lib64/R/library/Rcpp/include" -I"/usr/lib64/R/library/RcppArmadillo/include" -I"/tmp/RtmpXROjK2/sourceCpp-x86_64-redhat-linux-gnu-0.12.7"   -I/opt/ptools/lpaggreg/include/ -fpic  -O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic -c file419b7d5bd2e4.cpp -o file419b7d5bd2e4.o
g++ -m64 -std=c++11 -shared -L/usr/lib64/R/lib -Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -o sourceCpp_2.so file419b7d5bd2e4.o -llapack -lblas -lgfortran -lm -lquadmath -L/opt/ptools/lpaggreg/lib/ -llpaggreg -Wl,-rpath=/opt/ptools/lpaggreg/lib/ -L/usr/lib64/R/lib -lR
> 
> set.seed(345)
> #Synthetic example: 2 processes, 2 types, 5 timeslices (keep the same order)
> testArray = array(dim=c(2,2,5))
> testArray[1,1,] = c(0.5, 0.2, 0.0, 0.1, 0.4)
> testArray[1,2,] = c(0.5, 0.8, 1.0, 0.9, 0.6)
> testArray[2,1,] = c(0.4, 0.3, 0.1, 0.2, 0.3)
> testArray[2,2,] = c(0.6, 0.7, 0.9, 0.8, 0.7)
> print(testArray)
, , 1

     [,1] [,2]
[1,]  0.5  0.5
[2,]  0.4  0.6

, , 2

     [,1] [,2]
[1,]  0.2  0.8
[2,]  0.3  0.7

, , 3

     [,1] [,2]
[1,]  0.0  1.0
[2,]  0.1  0.9

, , 4

     [,1] [,2]
[1,]  0.1  0.9
[2,]  0.2  0.8

, , 5

     [,1] [,2]
[1,]  0.4  0.6
[2,]  0.3  0.7

> #Configuring threshold (0<threshold<1). A lower value means more accuracy but also more computation time
> #threshold = 0.001
> #Output: a 2D matrix (n,3) with the list of parts for each parameter
> #Columns: parameter p, start timeslice, end timeslice
> oaggregate(testArray)

 *** caught segfault ***
address 0x38, cause 'memory not mapped'

Traceback:
 1: .Primitive(".Call")(<pointer: 0x7f539f651e10>, data)
 2: oaggregate(testArray)
aborting ...
